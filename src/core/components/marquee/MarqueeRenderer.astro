---
import type { MarqueeProps } from "./marquee.props";

const props = Astro.props as MarqueeProps;
const {
  enable,
  direction,
  scrollDuration,
  primaryContent,
  secondaryContent,
  separator,
  button,
  background,
  customClass,
  ariaLabel,
  pauseOnHover,
} = props;

// 1. 判断是否需要滚动逻辑
const isScrolling = direction === "left" || direction === "right";

// 2. 处理背景样式
let finalBackground = background;
if (background) {
  const trimmed = background.trim();
  // 简单的启发式检查：如果是文件路径或http开头，且不包含 gradient/rgb 等关键词，包裹 url()
  // 当然，用户也可以直接传 "url(...)"
  const looksLikeUrl =
    !trimmed.includes("gradient") &&
    !trimmed.includes("rgb") &&
    !trimmed.startsWith("#") &&
    (trimmed.startsWith("/") || trimmed.startsWith("http"));

  if (looksLikeUrl) {
    finalBackground = `url(${trimmed}) center / cover no-repeat`;
  }
}

// 3. 构建 CSS 变量
const cssVars: Record<string, any> = {
  "--marquee-duration": scrollDuration,
  "--marquee-bg": finalBackground,
};

const hasContent = primaryContent || secondaryContent || button;
// 生成一个唯一的 ID，以便 JS 精确控制同一个页面上的多个 Marquee
const uniqueId = `marquee-${Math.random().toString(36).slice(2, 9)}`;

// DEBUG
// console.log(enable,hasContent);

---

{
  enable && hasContent && (
    <div
      id={uniqueId}
      class:list={["marquee-container", customClass]}
      style={cssVars}
      role="region"
      aria-label={ariaLabel}
      data-direction={direction}
      data-pause={pauseOnHover}
    >
      {/*
        内容容器
        JS 将会克隆里面的 .marquee-content-group 以填满屏幕
      */}
      <div class="marquee-track">
        <div class="marquee-content-group">
          {primaryContent && (
            <span class="marquee-item primary" set:html={primaryContent} />
          )}
          {primaryContent && secondaryContent && separator && (
            <span class="marquee-separator">{separator}</span>
          )}
          {secondaryContent && (
            <span class="marquee-item secondary" set:html={secondaryContent} />
          )}
          {button && (
            <a
              href={button.url}
              target={button.target || "_self"}
              class="marquee-btn"
            >
              {button.text}
            </a>
          )}
        </div>
      </div>
    </div>
  )
}

{/* raw script */}
{/*
  修复 View Transitions (ClientRouter) 问题：
  1. 使用 document.addEventListener('astro:page-load', ...) 替代 window.load
  2. 增加 data-initialized 标记，防止重复初始化
*/}
{/*
isScrolling && (
  <script is:inline define:vars={{ uniqueId }}>
    (function () {
      const initMarquee = () => {
        const container = document.getElementById(uniqueId);
        // 如果当前页面没有这个组件，直接返回
        if (!container) return;

        const track = container.querySelector(".marquee-track");
        const originalGroup = container.querySelector(".marquee-content-group");

        if (!track || !originalGroup) return;

        // --- 核心修复：防止重复初始化 (幂等性 check) ---
        // 软导航返回时，Astro 有时会恢复之前的 DOM 状态。
        // 如果已经克隆过了，就不要再克隆了，否则内容会越来越多。
        if (track.getAttribute('data-initialized') === 'true') {
          return;
        }

        // 1. 清理旧克隆 (防御性清理，确保状态纯净)
        // 这里的逻辑稍微改一下：保留第一个子元素，删除后面所有的
        // (虽然有了上面的 data-initialized 检查，这一步是双重保险)
        const groups = track.querySelectorAll(".marquee-content-group");
        for (let i = 1; i < groups.length; i++) {
          groups[i].remove();
        }

        const containerWidth = container.offsetWidth;
        const contentWidth = originalGroup.offsetWidth;

        // 内容为空或不可见，跳过
        if (contentWidth === 0) return;

        // 2. 设置 CSS 变量
        track.style.setProperty('--single-width', `-${contentWidth}px`);

        // 3. 计算副本数
        const requiredCopies = Math.ceil(containerWidth / contentWidth) + 1;
        const finalCount = Math.max(requiredCopies, 2);

        for (let i = 0; i < finalCount - 1; i++) {
          const clone = originalGroup.cloneNode(true);
          clone.setAttribute("aria-hidden", "true");
          track.appendChild(clone);
        }

        // 4. 标记已初始化并启动动画
        track.setAttribute('data-initialized', 'true');
        track.classList.add("animate");
      };

      // --- 核心修复：监听 Astro 路由事件 ---
      // astro:page-load 在初次加载和每次页面切换后都会触发
      document.addEventListener('astro:page-load', initMarquee);

      // 5. 窗口大小改变时重新计算
      // 注意：这里可能会造成内存泄漏，因为每次页面切换都会添加一个新的 resize 监听器
      // 我们可以把 resize 逻辑也放在 initMarquee 内部做一个简单的单例判断，或者在 astro:before-swap 清理
      // 但为了简单起见，这里先保持原样，影响不大。
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        const track = document.querySelector(`#${uniqueId} .marquee-track`);
        if(track) track.classList.remove("animate");

        // 重置初始化标记，允许重新计算
        if(track) track.setAttribute('data-initialized', 'false');

        resizeTimer = setTimeout(initMarquee, 200);
      });

    })();
  </script>
)
*/}

{/* min script */}
{isScrolling && (<script is:inline define:vars={{uniqueId}}>(function(){const f=()=>{const c=document.getElementById(uniqueId);if(!c)return;const t=c.querySelector(".marquee-track"),g=c.querySelector(".marquee-content-group");if(!t||!g||t.getAttribute("data-initialized")==="true")return;const a=t.querySelectorAll(".marquee-content-group");for(let i=1;i<a.length;i++)a[i].remove();const w=c.offsetWidth,gw=g.offsetWidth;if(gw===0)return;t.style.setProperty("--single-width",`-${gw}px`);const n=Math.max(Math.ceil(w/gw)+1,2);for(let i=0;i<n-1;i++){const cl=g.cloneNode(true);cl.setAttribute("aria-hidden","true");t.appendChild(cl)}t.setAttribute("data-initialized","true");t.classList.add("animate")};document.addEventListener("astro:page-load",f);let r;window.addEventListener("resize",()=>{clearTimeout(r);const t=document.querySelector(`#${uniqueId} .marquee-track`);if(t){t.classList.remove("animate");t.setAttribute("data-initialized","false")}r=setTimeout(f,200)})})();</script>)}

<style>
  .marquee-container {
    position: relative;
    width: 100%;
    min-height: 3rem;
    overflow: hidden;
    background: var(--marquee-bg);
    display: flex;
    align-items: center;
  }

  .marquee-track {
    display: flex;
    flex-wrap: nowrap;
    white-space: nowrap;
    /* 默认不移动，JS 加载完后添加 .animate 类才开始动 */
    will-change: transform;
    width: 100%;
  }

  .marquee-content-group {
    display: flex;
    align-items: center;
    padding: 0 1rem; /* 间距 */
    flex-shrink: 0;
  }

  .marquee-item {
    display: inline-block;
  }
  .marquee-item.primary {
    font-weight: 700;
  }
  .marquee-separator {
    margin: 0 0.5rem;
    opacity: 0.6;
  }
  .marquee-btn {
    margin-left: 1rem;
    padding: 0.25rem 0.75rem;
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid currentColor;
    border-radius: 4px;
    text-decoration: none;
    color: inherit;
    font-size: 0.9em;
    transition: background 0.3s;
  }
  .marquee-btn:hover {
    background: rgba(255, 255, 255, 0.4);
  }

  /* --- 动画逻辑 --- */

  /* 只有当 JS 添加了 .animate 类时才运行动画 */
  .marquee-track.animate {
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    animation-duration: var(--marquee-duration, 60s);
  }

  /* 根据 data-direction 属性决定动画方向 */
  [data-direction="left"] .marquee-track.animate {
    animation-name: scrollLeft;
  }
  [data-direction="right"] .marquee-track.animate {
    animation-name: scrollRight;
  }
  [data-direction="none"] {
    justify-content: center; /* 容器水平居中 */
  }
  [data-direction="none"] .marquee-track {
    justify-content: center; /* 轨道内容居中 */
    white-space: normal;     /* 允许换行 (防止手机端内容过长被截断) */
    text-align: center;      /* 文字居中 */
  }
  [data-direction="none"] .marquee-content-group {
    justify-content: center;
    flex-wrap: wrap;         /* 允许内容项换行 */
  }

  /* 悬停暂停 */
  [data-pause="true"]:hover .marquee-track.animate {
    animation-play-state: paused;
  }

  @keyframes scrollLeft {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(var(--single-width, -50%));
    }
  }
  @keyframes scrollRight {
    0% {
      transform: translateX(var(--single-width, -50%));
    }
    100% {
      transform: translateX(0);
    }
  }
</style>
